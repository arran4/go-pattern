<!-- Code generated by cmd/bootstrap/main.go; DO NOT EDIT. -->
# go-pattern

`go-pattern` is a collection of pre-created `image.Image` implementations. It provides a variety of ready-to-use patterns that implement the standard Go image interface.

These patterns are designed to be:
- **Ready to use**: Instantly available as standard `image.Image` objects.
- **Composable**: Easily combined (e.g., zooming, transposing) to form complex visual structures.
- **Standard**: Fully compatible with any Go library that accepts `image.Image`.

## Patterns


### Tile Pattern



![Tile Pattern](tile.png)

```go
	gopher := NewScale(NewGopher(), ScaleFactor(0.25))
	// Tile the gopher in a 200x200 area
	return NewTile(gopher, image.Rect(0, 0, 200, 200))
```


### Null Pattern



![Null Pattern](null.png)

```go
	i := NewNull()
	f, err := os.Create(NullOutputFilename)
	if err != nil {
		panic(err)
	}
	defer func() {
		if e := f.Close(); e != nil {
			panic(e)
		}
	}()
	if err = png.Encode(f, i); err != nil {
		panic(err)
	}
```


### GridUnbounded Pattern



![GridUnbounded Pattern](grid_unbounded.png)

```go
	// 300x100 Grid
	// Col 0: Bounded (100x100)
	// Col 1: Unbounded (Should take remaining 200px)

	// bounded := NewChecker(color.Black, color.White) // Checkers default to 255x255 but here we want fixed?
	// Actually NewChecker returns default bounds.
	// Let's use NewCrop or just standard bounds behavior.
	// But `layout()` uses `image.Bounds()` if not `Bounded`.

	// Let's create a bounded Mock that is 100x100.
	hundred := 100
	zero := 0

	b := &boundedGopher{
		Image: NewScale(NewGopher(), ScaleSize(100, 100)),
		bounds: Bounds{
			Left:   &Range{Low: &zero, High: &zero},
			Right:  &Range{Low: &hundred, High: &hundred},
			Top:    &Range{Low: &zero, High: &zero},
			Bottom: &Range{Low: &hundred, High: &hundred},
		},
	}

	// Unbounded pattern: e.g. a generic Tile or Checker that we want to fill space.
	// NewChecker returns 255x255.
	// Let's wrap it in an unbounded structure.
	u := &unboundedPattern{
		Image: NewChecker(color.RGBA{200, 0, 0, 255}, color.White),
	}

	args := []any{
		FixedSize(300, 100),
		Row(Cell(b), Cell(u)),
	}
	for _, op := range ops {
		args = append(args, op)
	}

	return NewGrid(args...)
```


### Checker Pattern



![Checker Pattern](checker.png)

```go
	i := NewChecker(color.Black, color.White)
	f, err := os.Create(CheckerOutputFilename)
	if err != nil {
		panic(err)
	}
	defer func() {
		if e := f.Close(); e != nil {
			panic(e)
		}
	}()
	if err = png.Encode(f, i); err != nil {
		panic(err)
	}
```


### SimpleZoom Pattern



![SimpleZoom Pattern](simplezoom.png)

```go
	i := NewSimpleZoom(NewChecker(color.Black, color.White), 2)
	f, err := os.Create(SimpleZoomOutputFilename)
	if err != nil {
		panic(err)
	}
	defer func() {
		if e := f.Close(); e != nil {
			panic(e)
		}
	}()
	if err = png.Encode(f, i); err != nil {
		panic(err)
	}
```


### Transposed Pattern



![Transposed Pattern](transposed.png)

```go
	i := NewTransposed(NewDemoNull(), 10, 10)
	f, err := os.Create(TransposedOutputFilename)
	if err != nil {
		panic(err)
	}
	defer func() {
		if e := f.Close(); e != nil {
			panic(e)
		}
	}()
	if err = png.Encode(f, i); err != nil {
		panic(err)
	}
```


### Grid Pattern



![Grid Pattern](grid.png)

```go
	// Example 1: Simple 2x2 grid with Gophers
	// Shrink the Gopher so it fits better
	gopher := NewScale(NewGopher(), ScaleFactor(0.25))

	args := []any{
		Row(Cell(gopher), Cell(gopher)),
		Row(Cell(gopher), Cell(gopher)),
	}
	for _, op := range ops {
		args = append(args, op)
	}

	// Create a grid with explicit Rows
	return NewGrid(args...)
```


### Gopher Pattern



![Gopher Pattern](gopher.png)

```go
	i := NewGopher()
	f, err := os.Create(GopherOutputFilename)
	if err != nil {
		panic(err)
	}
	defer func() {
		if e := f.Close(); e != nil {
			panic(e)
		}
	}()
	if err = png.Encode(f, i); err != nil {
		panic(err)
	}
```



## License

This project is licensed under the BSD 3-Clause License - see the [LICENSE](LICENSE) file for details.
