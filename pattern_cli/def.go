package pattern_cli

import (
	"bufio"
	"fmt"
	"github.com/arran4/go-pattern/dsl"
	"image"
	"image/color"
	"image/png"
	"os"
	"strings"

	"github.com/arran4/go-pattern"
	"golang.org/x/image/colornames"
)

// Repl is a subcommand `pattern-cli repl`
func Repl() {
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Print("> ")
	funcMap := make(dsl.FuncMap)
	registerCommands(funcMap)
	for scanner.Scan() {
		input := scanner.Text()
		if input == "exit" || input == "quit" {
			break
		}
		if err := process(input, funcMap); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		}
		fmt.Print("> ")
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "Error reading stdin: %v\n", err)
		os.Exit(1)
	}
}

// Run is a subcommand `pattern-cli run`
func Run(pipeline string) {
	funcMap := make(dsl.FuncMap)
	registerCommands(funcMap)
	if err := process(pipeline, funcMap); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func process(input string, fm dsl.FuncMap) error {
	p, err := dsl.Parse(input)
	if err != nil {
		return err
	}
	_, err = p.Execute(fm, nil)
	return err
}

func registerCommands(fm dsl.FuncMap) {
	if RegisterGeneratedCommands != nil {
		RegisterGeneratedCommands(fm)
	}

	// Overrides or additional manual commands can go here.
	// For backward compatibility or specific behavior differences, we can keep the manual ones
	// or rely on the generated ones if they match.
	// The generated ones might be more strict or different in argument handling (e.g. no defaults for mirror).
	// Let's keep manual ones for now if they have logic not easily autogenerated (like 'hv' string parsing for mirror).
	// But `zoom` is `simplezoom` in generated? `fm["zoom"]` vs `fm["simplezoom"]`.
	// The generator uses the pattern name (lowercase). `NewSimpleZoom` -> `simplezoom`.
	// The existing CLI uses `zoom`.
	// We can add aliases here.

	if _, ok := fm["zoom"]; !ok {
		// If generated didn't provide "zoom" (it likely provided "simplezoom"), alias it.
		if sz, ok := fm["simplezoom"]; ok {
			fm["zoom"] = sz
		}
	}

	// Mirror in generated code expects bools. The manual one parses "h", "v", "hv".
	// We should keep the manual mirror command for better UX if the generated one is too raw.
	fm["mirror"] = func(args []string, input image.Image) (image.Image, error) {
		if input == nil {
			return nil, fmt.Errorf("mirror requires an input image")
		}
		horizontal := false
		vertical := false
		if len(args) > 0 {
			switch args[0] {
			case "h":
				horizontal = true
			case "v":
				vertical = true
			case "hv", "vh":
				horizontal = true
				vertical = true
			case "true": // Generated style might expect bool string?
				horizontal = true
			case "false":
				// noop
			default:
				return nil, fmt.Errorf("mirror argument must be 'h', 'v', or 'hv'")
			}
		} else {
			horizontal = true
		}
		return pattern.NewMirror(input, horizontal, vertical), nil
	}

	// Rotate in generated code expects int. Manual one also expects int.
	// Generated: `fm["rotate"]` calls `NewRotate(input, int)`.
	// Manual: `fm["rotate"]` does the same.
	// So generated one should be fine, but manual one has error checking "requires degrees".
	// Generated has "argument 1 (int) missing".
	// So we can let generated take precedence or keep manual.
	// If we want to ensure "checkers" works (generated is "checker" from NewChecker), we need alias.
	if _, ok := fm["checkers"]; !ok {
		if c, ok := fm["checker"]; ok {
			fm["checkers"] = c
		}
	}

	fm["save"] = func(args []string, input image.Image) (image.Image, error) {
		if input == nil {
			return nil, fmt.Errorf("save requires an input image")
		}
		if len(args) < 1 {
			return nil, fmt.Errorf("save requires a filename argument")
		}
		filename := args[0]
		f, err := os.Create(filename)
		if err != nil {
			return nil, err
		}
		defer f.Close()

		if strings.HasSuffix(filename, ".png") {
			if err := png.Encode(f, input); err != nil {
				return nil, err
			}
		} else {
			return nil, fmt.Errorf("unsupported file format: %s", filename)
		}
		fmt.Printf("Saved to %s\n", filename)
		return input, nil
	}
}

func parseColor(s string) (color.Color, error) {
	if c, ok := colornames.Map[s]; ok {
		return c, nil
	}
	return nil, fmt.Errorf("unknown color: %s", s)
}
